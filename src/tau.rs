// Tau Language - Network language with futures
use crate::value::{Value, FutureState};
use std::collections::HashMap;
use std::fs;
use std::io::Write;

pub fn parse_tau(input: &str, variables: &HashMap<String, Value>, parse_rho_fn: impl Fn(&str) -> Result<Value, String>) -> Result<Value, String> {
    let input = input.trim();

    // Handle proxy and agent generation from filename
    // Syntax: proxy "filename.t" or agent "filename.t"
    if input.starts_with("proxy ") {
        let filename = input[6..].trim().trim_matches('"').trim_matches('\'');
        return generate_proxy(filename);
    }

    if input.starts_with("agent ") {
        let filename = input[6..].trim().trim_matches('"').trim_matches('\'');
        return generate_agent(filename);
    }

    // Handle async operations
    if input.starts_with("async ") {
        let _operation = &input[6..];
        return Ok(Value::Future(FutureState::Pending));
    }

    // Handle await
    if input.starts_with("await ") {
        let var_name = input[6..].trim();
        if let Some(value) = variables.get(var_name) {
            match value {
                Value::Future(FutureState::Resolved(v)) => return Ok((**v).clone()),
                Value::Future(FutureState::Pending) => return Err("Future still pending".to_string()),
                Value::Future(FutureState::Rejected(e)) => return Err(e.clone()),
                _ => return Ok(value.clone()),
            }
        }
        return Err(format!("Variable {} not found", var_name));
    }

    // Default to Rho parsing
    parse_rho_fn(input)
}

pub fn generate_proxy_wrapper(filename: &str) -> Result<Value, String> {
    generate_proxy(filename)
}

fn generate_proxy(filename: &str) -> Result<Value, String> {
    // Read the source file
    let content = fs::read_to_string(filename)
        .map_err(|e| format!("Failed to read file {}: {}", filename, e))?;

    // Extract base name without extension
    let base_name = filename
        .trim_end_matches(".tsu")
        .split(['/', '\\'])
        .last()
        .unwrap_or(filename);

    // Create App/Network directory
    fs::create_dir_all("App/Network")
        .map_err(|e| format!("Failed to create App/Network directory: {}", e))?;

    // Generate proxy header filename: {name}Proxy.h
    let proxy_header = format!("{}Proxy.h", base_name);

    // Generate proxy header content
    let proxy_header_content = format!(
        "// Proxy header for {}\n\
         // Generated by Tau language\n\
         \n\
         #ifndef {}_PROXY_H\n\
         #define {}_PROXY_H\n\
         \n\
         class {}Proxy {{\n\
         public:\n\
             {}Proxy();\n\
             void execute();\n\
             void monitor();\n\
         private:\n\
             // Original implementation\n\
         }};\n\
         \n\
         #endif // {}_PROXY_H\n",
        filename,
        base_name.to_uppercase(),
        base_name.to_uppercase(),
        base_name,
        base_name,
        base_name.to_uppercase()
    );

    // Generate App/Network implementation file
    let network_file = format!("App/Network/{}.tsu", base_name);
    let network_content = format!(
        "# Network implementation for {}\n\
         # Generated by Tau language\n\
         \n\
         :tau\n\
         \n\
         # Proxy wraps original code with monitoring\n\
         proxy_start = \"Proxy activated for {}\"\n\
         \n\
         # Original code:\n\
         {}\n\
         \n\
         proxy_end = \"Proxy finished for {}\"\n",
        filename, filename, content, filename
    );

    // Write proxy header
    let mut header_file = fs::File::create(&proxy_header)
        .map_err(|e| format!("Failed to create proxy header: {}", e))?;
    header_file.write_all(proxy_header_content.as_bytes())
        .map_err(|e| format!("Failed to write proxy header: {}", e))?;

    // Write network implementation
    let mut network_file_handle = fs::File::create(&network_file)
        .map_err(|e| format!("Failed to create network file: {}", e))?;
    network_file_handle.write_all(network_content.as_bytes())
        .map_err(|e| format!("Failed to write network file: {}", e))?;

    Ok(Value::Str(format!("Proxy generated: {} and {}", proxy_header, network_file)))
}

pub fn generate_agent_wrapper(filename: &str) -> Result<Value, String> {
    generate_agent(filename)
}

fn generate_agent(filename: &str) -> Result<Value, String> {
    // Read the source file
    let content = fs::read_to_string(filename)
        .map_err(|e| format!("Failed to read file {}: {}", filename, e))?;

    // Extract base name without extension
    let base_name = filename
        .trim_end_matches(".tsu")
        .split(['/', '\\'])
        .last()
        .unwrap_or(filename);

    // Create App/Network directory
    fs::create_dir_all("App/Network")
        .map_err(|e| format!("Failed to create App/Network directory: {}", e))?;

    // Generate agent header filename: {name}Agent.h
    let agent_header = format!("{}Agent.h", base_name);

    // Generate agent header content
    let agent_header_content = format!(
        "// Agent header for {}\n\
         // Generated by Tau language\n\
         \n\
         #ifndef {}_AGENT_H\n\
         #define {}_AGENT_H\n\
         \n\
         class {}Agent {{\n\
         public:\n\
             {}Agent();\n\
             void start();\n\
             void stop();\n\
             bool isRunning();\n\
         private:\n\
             bool running;\n\
             // Async execution context\n\
         }};\n\
         \n\
         #endif // {}_AGENT_H\n",
        filename,
        base_name.to_uppercase(),
        base_name.to_uppercase(),
        base_name,
        base_name,
        base_name.to_uppercase()
    );

    // Generate App/Network agent implementation
    let network_agent_file = format!("App/Network/{}Agent.tsu", base_name);
    let agent_content = format!(
        "# Agent for {}\n\
         # Generated by Tau language\n\
         \n\
         :tau\n\
         \n\
         # Agent: autonomous executor that runs in background\n\
         agent_name = \"Agent-{}\"\n\
         agent_status = \"running\"\n\
         \n\
         # Agent wraps code in async execution context\n\
         async {{\n\
         \t# Original code:\n\
         \t{}\n\
         }}\n\
         \n\
         agent_complete = \"Agent finished\"\n",
        filename,
        filename.replace(".", "_"),
        content.lines()
            .map(|line| format!("\t{}", line))
            .collect::<Vec<_>>()
            .join("\n")
    );

    // Write agent header
    let mut header_file = fs::File::create(&agent_header)
        .map_err(|e| format!("Failed to create agent header: {}", e))?;
    header_file.write_all(agent_header_content.as_bytes())
        .map_err(|e| format!("Failed to write agent header: {}", e))?;

    // Write network agent implementation
    let mut agent_file_handle = fs::File::create(&network_agent_file)
        .map_err(|e| format!("Failed to create network agent file: {}", e))?;
    agent_file_handle.write_all(agent_content.as_bytes())
        .map_err(|e| format!("Failed to write network agent file: {}", e))?;

    Ok(Value::Str(format!("Agent generated: {} and {}", agent_header, network_agent_file)))
}
